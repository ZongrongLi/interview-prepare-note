容器的原理
不同于虚拟机, 虚拟化, docker 只是使用了linux 的namespace , 使用clone 创建一片新的空间, pid 从1开始分配
隔离与限制
Namespace 技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制
用户运行在容器里的应用进程，跟宿主机上的其他进程一样，都由宿主机操作系统统一管理，更多的是旁路式的辅助和管理工作。
一个运行着 CentOS 的 KVM 虚拟机启动后，在不做优化的情况下，虚拟机自己就需要占用 100~200 MB 内存

却依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的

其中最主要的问题就是：隔离得不彻底。


其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。

就是希望容器和应用能够同生命周期
容器的资源限制（cpu，memory大小等）是通过linux cgroups实现


启用 Linux Namespace 配置；
设置指定的 Cgroups 参数；切换进程的根目录（Change Root）。
namespace  是再物力资源之上的概念性的的东西进行隔离
cgroup 是对cpu资源网络带宽
然后是文件系统进行隔离


访问关系, 代理关系 调用关系
其实，这种任务与任务之间的关系，在我们平常的各种技术场景中随处可见。比如，
一个 Web 应用与数据库之间的访问关系
一个负载均衡器和它的后端服务之间的代理关系
一个门户应用与授权组件之间的调用关系。

哪些是主 那些是从



所以，Kubernetes 项目的做法是给 Pod 绑定一个 Service 服务，而 Service 服务声明的 IP 地址等信息是“终生不变”的。这个 Service 服务的主要作用，就是作为 Pod 的代理入口（Portal），从而代替 Pod 对外暴露一个固定的网络地址。

Kubernetes 项目提供了一种叫作 Secret 的对象，它其实是一个保存在 Etcd 里的键值对数据。这样，你把 Credential 信息以 Secret 的方式存在 Etcd 里，Kubernetes 就会在你指定的 Pod（比如，Web 应用的 Pod）启动时，自动把 Secret 里的数据以 Volume 的方式挂载到容器里。这样，这个 Web 应用就可以访问数据库了。


编排对象和服务对象
首先，通过一个“编排对象”，比如 Pod、Job、CronJob 等，来描述你试图管理的应用；

再为它定义一些“服务对象”，比如 Service、Secret、Horizontal Pod Autoscaler（自动水平扩展器）等。这些对象，会负责具体的平台级功能。

master:
etcd apiserver controller scheduler
node:
。实际运行这些 Pod 的组件称为kubelet，
它从 API 服务器接收所需 Pod 的运行状态，并将运行状态提交给如下图所示的容器运行时组件。
kublet

而当应用本身发生变化时，开发人员和运维人员可以依靠容器镜像来进行同步；当应用部署参数发生变化时，这些 YAML 文件就是他们相互沟通和信任的媒介。


为什么我们会需要 Pod？
容器的本质是进程。

Pod，其实是一组共享了某些资源的容器。
Pod 里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume。

Pod 的实现需要使用一个中间容器，这个容器叫作 Infra 容器。在这个 Pod 中，Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。


Pod 这种“超亲密关系”容器的设计思想，实际上就是希望，当用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器。

Pod 扮演的是传统部署环境里“虚拟机”的角色。


1. cgroup用于隔离cgroup根目录;
2. IPC用于隔离系统消息队列;
3. Network隔离网络;
4. Mount隔离挂载点;
5. PID隔离进程;
6. User隔离用户和用户组;
7. UTS隔离主机名nis域名。


secret
抓在volumn 访问etcd 中的用户名密码

比如，增加 Pod，删除已有的 Pod，或者更新 Pod 的某个字段。这也是 Kubernetes 项目“面向 API 对象编程”的一个直观体现。其实，像 Deployment 这种控制器的设计原理，就是我们前面提到过的，“用一种对象管理另一种对象”的“艺术”。